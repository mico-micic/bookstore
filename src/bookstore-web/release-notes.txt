========================================================
      BookStore By Thomas Siegrist and Mico Micic
 
                   Release Notes


 CAS Enterprise Application Development Java EE | EADJ
========================================================

Version: 0.1-jsf
Datum:   14.11.2014
===================

Grundaufbau:
--------------

Der BookStore basiert aktuell auf dem Bookstore-Mock und beinhaltet folgende
Grundfunktionen:

    * Benutzer-Registration
    * Benutzer-Login
    * Benutzer-Profil anzeigen und bearbeiten
    * Suche nach Büchern als Freitext oder mit ISBN-Nummer
    * Anzeige von Details zu einzelnen Büchern
    * Ablegen von Büchern im Warenkorb
    * Anzeige des Warenkorbes mit der Möglichkeit, diesen zu verändern
    * Bestellung absenden
    * Getätigte Bestellungen anzeigen und (wenn möglich) abbrechen
    * Mehrsprachigkeit Deutsch / Englisch mit Browsererkennung und manueller
      Sprachumstellung

Backing Beans:
--------------

Folgende Backing Beans sind aktuell umgesetzt:

    * CartBean:      Beinhaltet alle Funktionen rund um den Einkaufskorb
    * CatalogBean:   Suche nach Büchern und Anzeige der Buchdetails
    * CountriesBean: Stellt die unterstützten Länder zur Verfügung
    * CustomerBean:  Für alle Funktionen welche den Benutzer und auch dessen
                     Bestellungen betreffen
    * LocaleBean:    Handling der Mehrsprachigkeit
    * LoginBean :    Login / Logout Funktionalität

Besonderheiten:

    * Für das Projekt wird JAVA 8 verwendet. Dies erlaubt es z.B. die Berechnung
      des Warenkorbes mit Streams zu lösen. Siehe Cart#getTotalBooksInCart und
      Cart#getTotalPrice. Auch das Sortieren einer Liste nach z.B. Datum ist 
      somit einfacher. Beispiel: CustomerBean#findAllOrdersOfYear.
    * Die unterstützten Länder werden aus einer Konfig-Datei geladen und 
      automatisch in die aktuell eingestellte Sprache übersetzt. Siehe dazu
      CountriesBean.
    * Das Verändern des Warenkorbes (Anzahl plus / minus, löschen), das
      Laden der getätigten Bestellungen pro Jahr, sowie das Abbrechen einer 
      Bestellung wird per AJAX gemacht.

Template:
--------------

Das Template wurde von einer freien Quelle übernommen 
(http://www.coolwebtemplates.net/) und leicht angepasst. 

Besonderheiten:

    * Das Template befindet sich unter Web Pages/template/default. Mit "default" 
      wird eine weitere Ebene resp. Library geschaffen damit das Template 
      zukünftig leicht austauschbar resp. erweiterbar ist.
    * Folgende Elemente werden mindestens an zwei Orten der Seite verwendet und
      wurden daher als Composite Components ausgelagert:
        - "cartView":  Warenkorbansicht mit drei Parametern zur Steuerung 
                       des Layouts
        - "editableAccount": Component zum Bearbeiten des Benutzer-Profils
        - "readableAccount": Component zum Anzeigen des Benutzer-Profils
        - "search": Component für die Suche (Freitext und ISBN)
      Bei allen Components wurden auch Bilder und CSS-Dateien mit ausgelagert.
    * Das Template hat auf der rechten Seite sogenannte Gadgets. Auch diese sind
      im Sinne der Wiederverwenung unter Web Pages/gadgets als UI-Compositions
      (sprich: Fragments) ausgelagert.
    * Folgende JavaScript Libraries werden eingesetzt:
        - Cufon:     Fonts-Handling, bei Template inbegriffen
        - radius.js: Border-Radius, bei Template inbegriffen
        - jQuery:    Basis JavaScript Framework
        - qtip:      jQuery Erweiterung für Anzeige von Tool-Tipps
        - toastr:    Anzeige von globalen Messages
        - simplemodal: Anzeige des AJAX-Ladebalken
    * Im defaultTemplate.xhtml wurde ein JavaScript Code-Block integriert, der
      das Absetzen von AJAX-Requests automatisch erkennt und bis zur Antwort 
      einen animierten Ladebalken anzeigt.

Navigation:
--------------

Für die Navigation hatten wir zwei Strategien abgewägt:
    * Für jede Action ein Navigation-Case (oder mehrere bei verschiedenen 
      Outcomes)
    * Für jede seite ein Navigation-Case mit einem 1:1 Mapping auf einen Outcome
Wir haben uns auf Grund des praktischen Handlings im Java Code für Variante 2
entschieden. Pro Outcome haben wir so genau eine Steite. Für jeden Outcome git
es einen Wert im Enum 'EnumActionResult'.

State-Based-Navigation:

Der Back-Button war eine grosse Herausforderung. Wir haben es so gelöst, dass
wir für alle Navigationen, welche auf Seiten mit einem Back Button führen, der
Weg zurück angegeben werden muss.

Bsp: catalogBean.setBookSelection(lineItem.book, 'CART') mit Outcome: 'BOOK'
 => wobei 'CART' die Zielseite festlegt, wenn man auf der Buch-Seite auf
    zurück klickt.

Wir hatten auch generischere Ansätze probiert, bei dennen wir versucht haben,
uns jeweils die letzte Seite zu merken, doch da hatten uns die Vor- Zurück- und
Aktualisieren-Buttons des Browsers einen Strich durch die Rechnung gemacht
(auch wenn wir die Info aus dem Context abgefragt hatten).

Die dynamische Navigation beim Login haben wir nach dem gleichen Prinzip
umgesetzt.

Messaging:
--------------

Alle Meldungen (globale wie auch für einzelne Komponenten) werden mit den JSF
Boardmitteln umgesetzt. Die Ausgabe erfolgt dabei jedoch in ein Hidden-Div. 
Dieses wird nach dem Laden der Seite durch JavaScript entweder als Tool-Tipp
(im Fall einer komponentenbezogenen Meldung) oder grafisch aufbereiteter Balken
dargestellt. Dies erfolgt mit den jQuery Libraries qtip und toaster. Siehe dazu
defaultTemplate.xhtml.

Offene Punkte:
--------------
* Die Links "Hilfe" und "Kontakt" funktionieren nicht (Noch nicht umgesetzt)